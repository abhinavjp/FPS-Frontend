import { Predicate, Reducer, Transformer } from './common.interfaces';
/**
 * @hidden
 * Performs the right-to-left function composition. Functions should have a unary.
 */
export declare const compose: (...args: any[]) => (data: any) => any;
/**
 * @hidden
 */
export declare const groupCombinator: (field: any) => (agg: any, value: any) => any;
/**
 * @hidden
 */
export declare const expandAggregates: (result?: {}) => {};
/**
 * @hidden
 */
export declare const aggregatesCombinator: (descriptors: any) => (state: any, value: any) => any;
/**
 * @hidden
 * Adds the value to the `arr` producing a new array.
 *
 * > The original array will be modified.
 */
export declare const concat: <T>(arr: T[], value: T) => T[];
/**
 * @hidden
 * Returns a reducer that will apply the specified transformation to the value.
 */
export declare const map: (transform: any) => Reducer;
/**
 * @hidden
 * Returns a reducer that will filter out items which do not match the `Predicate`.
 */
export declare const filter: (predicate: any) => Reducer;
/**
 * @hidden
 */
export declare const isTransformerResult: <T>(source: {
    __value: T;
    reduced: boolean;
}) => source is {
    __value: T;
    reduced: boolean;
};
/**
 * @hidden
 * Returns a reducer that will take the specified number of items.
 */
export declare const take: (count: number) => Reducer;
/**
 * @hidden
 * Returns a reducer that will take the specified number of items.
 */
export declare const takeWhile: (predicate: Predicate) => Reducer;
/**
 * @hidden
 * Returns a reducer that will skip the specified number of items.
 */
export declare const skip: (count: number) => Reducer;
/**
 * @hidden
 * Transforms the data by applying the supplied transformer.
 */
export declare const exec: <T, U>(transform: Transformer, initialValue: U, data: T[]) => U;
